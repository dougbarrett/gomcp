package seeders

import (
	"context"
	"fmt"
	"log"
	[[- if .HasDistributions]]
	"math/rand"
	[[- end]]

	"[[.ModulePath]]/internal/models"
	[[- if .HasRelationships]]
	[[- range .Relationships]]
	"[[$.ModulePath]]/internal/repository/[[.ModelVar | toSnakeCase]]"
	[[- end]]
	[[- end]]
	"gorm.io/gorm"
	[[- if .WithFaker]]
	"github.com/brianvoe/gofakeit/v6"
	[[- end]]
)

// [[.ModelName]]Seeder seeds [[.ModelName]] records.
type [[.ModelName]]Seeder struct {
	db *gorm.DB
	[[- if .HasRelationships]]
	[[- range .Relationships]]
	[[.ModelVar]]Repo *[[.ModelVar | toSnakeCase]].Repository
	[[- end]]
	[[- end]]
}

// New[[.ModelName]]Seeder creates a new [[.ModelName]]Seeder.
func New[[.ModelName]]Seeder(db *gorm.DB) *[[.ModelName]]Seeder {
	return &[[.ModelName]]Seeder{
		db: db,
		[[- if .HasRelationships]]
		[[- range .Relationships]]
		[[.ModelVar]]Repo: [[.ModelVar | toSnakeCase]].NewRepository(db),
		[[- end]]
		[[- end]]
	}
}

// Seed creates [[.Count]] [[.ModelName]] records.
func (s *[[.ModelName]]Seeder) Seed(ctx context.Context) error {
	log.Printf("Seeding [[.Count]] [[pluralize .ModelName | toLower]]...")

	[[- if .WithFaker]]
	gofakeit.Seed(0)
	[[- end]]

	[[- if .HasRelationships]]

	// Fetch related records for relationships
	[[- range .Relationships]]
	[[.ModelVar | toLower]]s, err := s.[[.ModelVar]]Repo.FindAll(ctx)
	if err != nil {
		return fmt.Errorf("failed to fetch [[pluralize .Model | toLower]]: %w", err)
	}
	if len([[.ModelVar | toLower]]s) == 0 {
		return fmt.Errorf("no [[pluralize .Model | toLower]] found - run [[.Model | toLower]] seeder first")
	}
	[[.ModelVar | toLower]]IDs := make([]uint, len([[.ModelVar | toLower]]s))
	for i, r := range [[.ModelVar | toLower]]s {
		[[.ModelVar | toLower]]IDs[i] = r.ID
	}
	[[- end]]
	[[- end]]

	[[- if .HasDistributions]]

	// Build distribution pools for fields with specific value distributions
	[[- range $dist := .Distributions]]
	[[$dist.Field | toLower]]Pool := [][[fieldGoType $dist.Field $.Fields]]{}
	[[- range $dist.Values]]
	for i := 0; i < [[.Count]]; i++ {
		[[$dist.Field | toLower]]Pool = append([[$dist.Field | toLower]]Pool, [[.Value]])
	}
	[[- end]]
	// Shuffle the pool for random distribution
	rand.Shuffle(len([[$dist.Field | toLower]]Pool), func(i, j int) {
		[[$dist.Field | toLower]]Pool[i], [[$dist.Field | toLower]]Pool[j] = [[$dist.Field | toLower]]Pool[j], [[$dist.Field | toLower]]Pool[i]
	})
	[[- end]]
	[[- end]]

	for i := 0; i < [[.Count]]; i++ {
		item := models.[[.ModelName]]{
			[[- range .Fields]]
			[[- if not (isDistributedField .Name $.Distributions)]]
			[[.Name]]: [[fakerFunc .Type]],
			[[- end]]
			[[- end]]
			[[- range .Distributions]]
			[[.Field]]: [[.Field | toLower]]Pool[i % len([[.Field | toLower]]Pool)],
			[[- end]]
			[[- range .Relationships]]
			[[- if eq .Strategy "random"]]
			[[.Field]]: [[.ModelVar | toLower]]IDs[gofakeit.Number(0, len([[.ModelVar | toLower]]IDs)-1)],
			[[- else if eq .Strategy "distribute"]]
			[[.Field]]: [[.ModelVar | toLower]]IDs[i % len([[.ModelVar | toLower]]IDs)],
			[[- else if eq .Strategy "each"]]
			[[.Field]]: [[.ModelVar | toLower]]IDs[i % len([[.ModelVar | toLower]]IDs)],
			[[- end]]
			[[- end]]
		}

		if err := s.db.WithContext(ctx).Create(&item).Error; err != nil {
			return fmt.Errorf("failed to seed [[.ModelName | toLower]] %d: %w", i+1, err)
		}
	}

	log.Printf("Successfully seeded [[.Count]] [[pluralize .ModelName | toLower]]")
	return nil
}

// Clear removes all [[.ModelName]] records.
func (s *[[.ModelName]]Seeder) Clear(ctx context.Context) error {
	log.Printf("Clearing all [[pluralize .ModelName | toLower]]...")

	if err := s.db.WithContext(ctx).Exec("DELETE FROM [[.TableName]]").Error; err != nil {
		return fmt.Errorf("failed to clear [[pluralize .ModelName | toLower]]: %w", err)
	}

	// Reset auto-increment (SQLite)
	s.db.WithContext(ctx).Exec("DELETE FROM sqlite_sequence WHERE name='[[.TableName]]'")

	log.Printf("Cleared all [[pluralize .ModelName | toLower]]")
	return nil
}

// Count returns the number of [[.ModelName]] records.
func (s *[[.ModelName]]Seeder) Count(ctx context.Context) (int64, error) {
	var count int64
	if err := s.db.WithContext(ctx).Model(&models.[[.ModelName]]{}).Count(&count).Error; err != nil {
		return 0, err
	}
	return count, nil
}

// SeedIfEmpty seeds only if table is empty.
func (s *[[.ModelName]]Seeder) SeedIfEmpty(ctx context.Context) error {
	count, err := s.Count(ctx)
	if err != nil {
		return err
	}

	if count > 0 {
		log.Printf("Skipping [[.ModelName | toLower]] seeding: %d records already exist", count)
		return nil
	}

	return s.Seed(ctx)
}

[[- if .Dependencies]]

// Dependencies returns seeders that must run before this one.
func (s *[[.ModelName]]Seeder) Dependencies() []string {
	return []string{
		[[- range .Dependencies]]
		"[[.]]",
		[[- end]]
	}
}
[[- end]]

/*
SEEDING EXAMPLES:

1. Basic seeding with count:
   seeder := seeders.New[[.ModelName]]Seeder(db)
   seeder.Seed(ctx)

2. Seed only if empty:
   seeder.SeedIfEmpty(ctx)

3. Clear and reseed:
   seeder.Clear(ctx)
   seeder.Seed(ctx)

[[- if .HasRelationships]]

RELATIONSHIP SEEDING:
This seeder fetches related records and assigns foreign keys.
Strategies:
- "random": Picks a random related record for each new record
- "distribute": Spreads records evenly across related records
- "each": Creates one record per related record (count should match)

Make sure to run dependency seeders first:
[[- range .Dependencies]]
  - [[.]] seeder
[[- end]]
[[- end]]

[[- if .HasDistributions]]

VALUE DISTRIBUTION:
This seeder distributes specific values across records.
The values are shuffled to randomize their order.
[[- end]]

CUSTOMIZATION:
To customize the seeding logic, modify the Seed() method above.
Common customizations:
- Add more realistic faker data (gofakeit.Email(), gofakeit.Name(), etc.)
- Add conditional logic based on index
- Create related records on-the-fly
*/
