package auth

import (
	"net/http"

	"[[.ModulePath]]/internal/services/auth"
	"[[.ModulePath]]/internal/web"
	"[[.ModulePath]]/internal/web/auth/views"
	"[[.ModulePath]]/internal/web/middleware"
	"github.com/go-chi/chi/v5"
)

// Controller handles auth HTTP requests.
type Controller struct {
	authService *auth.Service
}

// NewController creates a new auth Controller.
func NewController(authService *auth.Service) *Controller {
	return &Controller{authService: authService}
}

// RegisterRoutes registers all auth routes (login, register, logout).
// For applications that don't want public registration, use RegisterLoginRoutes instead.
func (c *Controller) RegisterRoutes(r chi.Router) {
	c.RegisterLoginRoutes(r)
	c.RegisterRegistrationRoutes(r)
}

// RegisterLoginRoutes registers only login and logout routes.
// Use this for admin-only applications where registration is not public.
func (c *Controller) RegisterLoginRoutes(r chi.Router) {
	r.Get("/login", c.ShowLogin)
	r.Post("/login", c.Login)
	r.Post("/logout", c.Logout)
}

// RegisterRegistrationRoutes registers only registration routes.
// Only mount this if you want public user registration.
func (c *Controller) RegisterRegistrationRoutes(r chi.Router) {
	r.Get("/register", c.ShowRegister)
	r.Post("/register", c.Register)
}

// ShowLogin renders the login page.
func (c *Controller) ShowLogin(w http.ResponseWriter, r *http.Request) {
	// Check if already logged in
	if c.authService.ValidateSession(r) {
		http.Redirect(w, r, c.authService.HomeRoute(), http.StatusSeeOther)
		return
	}

	web.NewResponse(w, r).Render(views.LoginPage(views.LoginProps{
		CSRFToken: middleware.GetCSRFToken(r.Context()),
	}))
}

// Login processes the login form.
func (c *Controller) Login(w http.ResponseWriter, r *http.Request) {
	csrfToken := middleware.GetCSRFToken(r.Context())

	if err := r.ParseForm(); err != nil {
		web.NewResponse(w, r).Render(views.LoginPage(views.LoginProps{
			Error:     "Invalid form data",
			CSRFToken: csrfToken,
		}))
		return
	}

	input := auth.LoginInput{
		Email:    r.FormValue("email"),
		Password: r.FormValue("password"),
		Remember: r.FormValue("remember") == "on",
	}

	// Validate input
	errors := make(map[string]string)
	if input.Email == "" {
		errors["email"] = "Email is required"
	}
	if input.Password == "" {
		errors["password"] = "Password is required"
	}

	if len(errors) > 0 {
		web.NewResponse(w, r).Render(views.LoginPage(views.LoginProps{
			Email:     input.Email,
			Errors:    errors,
			CSRFToken: csrfToken,
		}))
		return
	}

	// Attempt login
	_, err := c.authService.Login(r.Context(), w, r, input)
	if err != nil {
		web.NewResponse(w, r).Render(views.LoginPage(views.LoginProps{
			Email:     input.Email,
			Error:     err.Error(),
			CSRFToken: csrfToken,
		}))
		return
	}

	// Redirect to home route or intended URL
	redirectURL := r.URL.Query().Get("redirect")
	if redirectURL == "" {
		redirectURL = c.authService.HomeRoute()
	}

	if r.Header.Get("HX-Request") == "true" {
		w.Header().Set("HX-Redirect", redirectURL)
		return
	}

	http.Redirect(w, r, redirectURL, http.StatusSeeOther)
}

// ShowRegister renders the registration page.
func (c *Controller) ShowRegister(w http.ResponseWriter, r *http.Request) {
	// Check if already logged in
	if c.authService.ValidateSession(r) {
		http.Redirect(w, r, c.authService.HomeRoute(), http.StatusSeeOther)
		return
	}

	web.NewResponse(w, r).Render(views.RegisterPage(views.RegisterProps{
		CSRFToken: middleware.GetCSRFToken(r.Context()),
	}))
}

// Register processes the registration form.
func (c *Controller) Register(w http.ResponseWriter, r *http.Request) {
	csrfToken := middleware.GetCSRFToken(r.Context())

	if err := r.ParseForm(); err != nil {
		web.NewResponse(w, r).Render(views.RegisterPage(views.RegisterProps{
			Error:     "Invalid form data",
			CSRFToken: csrfToken,
		}))
		return
	}

	input := auth.RegisterInput{
		Name:            r.FormValue("name"),
		Email:           r.FormValue("email"),
		Password:        r.FormValue("password"),
		PasswordConfirm: r.FormValue("password_confirm"),
	}

	// Validate input
	errors := make(map[string]string)
	if input.Name == "" {
		errors["name"] = "Name is required"
	}
	if input.Email == "" {
		errors["email"] = "Email is required"
	}
	if input.Password == "" {
		errors["password"] = "Password is required"
	} else if len(input.Password) < 8 {
		errors["password"] = "Password must be at least 8 characters"
	}
	if input.Password != input.PasswordConfirm {
		errors["password_confirm"] = "Passwords do not match"
	}

	if len(errors) > 0 {
		web.NewResponse(w, r).Render(views.RegisterPage(views.RegisterProps{
			Name:      input.Name,
			Email:     input.Email,
			Errors:    errors,
			CSRFToken: csrfToken,
		}))
		return
	}

	// Attempt registration
	_, err := c.authService.Register(r.Context(), w, r, input)
	if err != nil {
		if err == auth.ErrEmailExists {
			errors["email"] = "This email is already registered"
			web.NewResponse(w, r).Render(views.RegisterPage(views.RegisterProps{
				Name:      input.Name,
				Email:     input.Email,
				Errors:    errors,
				CSRFToken: csrfToken,
			}))
			return
		}
		web.NewResponse(w, r).Render(views.RegisterPage(views.RegisterProps{
			Name:      input.Name,
			Email:     input.Email,
			Error:     "Failed to create account. Please try again.",
			CSRFToken: csrfToken,
		}))
		return
	}

	// Redirect to home route
	homeRoute := c.authService.HomeRoute()
	if r.Header.Get("HX-Request") == "true" {
		w.Header().Set("HX-Redirect", homeRoute)
		return
	}

	http.Redirect(w, r, homeRoute, http.StatusSeeOther)
}

// Logout logs the user out.
func (c *Controller) Logout(w http.ResponseWriter, r *http.Request) {
	c.authService.Logout(w, r)

	if r.Header.Get("HX-Request") == "true" {
		w.Header().Set("HX-Redirect", "/login")
		return
	}

	http.Redirect(w, r, "/login", http.StatusSeeOther)
}
