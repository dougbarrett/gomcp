package [[.PackageName]]

import (
	"net/http"
	"strconv"
	[[- if hasTimeFields .Fields]]
	"time"
	[[- end]]

	[[.PackageName]]svc "[[.ModulePath]]/internal/services/[[.PackageName]]"
	"[[.ModulePath]]/internal/web"
	[[- if .WithCrudViews]]
	"[[.ModulePath]]/internal/web/[[.PackageName]]/views"
	[[- if ne .Layout "none"]]
	"[[.ModulePath]]/internal/web/layouts"
	[[- end]]
	"[[.ModulePath]]/internal/web/middleware"
	[[- end]]
	[[- if and .WithCrudViews (hasBelongsTo .Relationships)]]
	[[- range .Relationships]]
	[[- if .IsBelongsTo]]
	[[.Model | toPackageName]]svc "[[$.ModulePath]]/internal/services/[[.Model | toPackageName]]"
	[[- end]]
	[[- end]]
	[[- end]]
	"github.com/a-h/templ"
	"github.com/go-chi/chi/v5"
)

// Controller handles HTTP requests for [[pluralize .ModelName]].
type Controller struct {
	service [[.PackageName]]svc.Service
	[[- if and .WithCrudViews (hasBelongsTo .Relationships)]]
	[[- range .Relationships]]
	[[- if .IsBelongsTo]]
	[[.Model | toVariableName]]Service [[.Model | toPackageName]]svc.Service
	[[- end]]
	[[- end]]
	[[- end]]
}

// NewController creates a new [[.ModelName]] controller.
[[- if and .WithCrudViews (hasBelongsTo .Relationships)]]
func NewController(service [[.PackageName]]svc.Service[[range .Relationships]][[if .IsBelongsTo]], [[.Model | toVariableName]]Service [[.Model | toPackageName]]svc.Service[[end]][[end]]) *Controller {
	return &Controller{
		service: service,
		[[- range .Relationships]]
		[[- if .IsBelongsTo]]
		[[.Model | toVariableName]]Service: [[.Model | toVariableName]]Service,
		[[- end]]
		[[- end]]
	}
}
[[- else]]
func NewController(service [[.PackageName]]svc.Service) *Controller {
	return &Controller{service: service}
}
[[- end]]

// RegisterRoutes registers the [[.ModelName]] routes on the given router.
// Mount this under any path: router.Route("/admin/[[.URLPathSegment]]", ctrl.RegisterRoutes)
func (c *Controller) RegisterRoutes(r chi.Router) {
	r.Get("/", c.List)
	r.Post("/", c.Create)
	r.Get("/new", c.New)
	r.Get("/{id}", c.Show)
	r.Get("/{id}/edit", c.Edit)
	r.Put("/{id}", c.Update)
	r.Delete("/{id}", c.Delete)
	// MCP:ROUTES:START
	// MCP:ROUTES:END
}

// render renders a templ component to the response.
func (c *Controller) render(w http.ResponseWriter, r *http.Request, component templ.Component) {
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	component.Render(r.Context(), w)
}

// List handles GET [[.URLPath]]
func (c *Controller) List(w http.ResponseWriter, r *http.Request) {
	res := web.NewResponse(w, r)

	// Parse query parameters
	page, _ := strconv.Atoi(r.URL.Query().Get("page"))
	pageSize, _ := strconv.Atoi(r.URL.Query().Get("page_size"))
	search := r.URL.Query().Get("search")
	sortBy := r.URL.Query().Get("sort_by")
	sortDesc := r.URL.Query().Get("sort_desc") == "true"

	filter := [[.PackageName]]svc.List[[.ModelName]]Filter{
		Page:     page,
		PageSize: pageSize,
		Search:   search,
		SortBy:   sortBy,
		SortDesc: sortDesc,
	}

	result, err := c.service.List(r.Context(), filter)
	if err != nil {
		res.Error(http.StatusInternalServerError, err.Error())
		return
	}

	[[- if .WithCrudViews]]
	props := views.[[.ModelName]]ListProps{
		Items:       result.Items,
		Page:        result.Page,
		TotalPages:  result.TotalPages,
		TotalItems:  result.TotalItems,
		CSRFToken:   middleware.GetCSRFToken(r.Context()),
		SearchQuery: search,
	}

	// For HTMX partial requests, render just the list content
	if res.IsHTMX() {
		c.render(w, r, views.[[.ModelName]]ListPartial(props))
		return
	}

	// For full page requests, wrap in layout
	[[- if eq .Layout "none"]]
	c.render(w, r, views.[[.ModelName]]List(props))
	[[- else if eq .Layout "base"]]
	c.render(w, r, layouts.BasePage("[[pluralize .ModelName]]", views.[[.ModelName]]List(props)))
	[[- else]]
	c.render(w, r, layouts.DashboardPage("[[pluralize .ModelName]]", views.[[.ModelName]]List(props)))
	[[- end]]
	[[- else]]
	// Return JSON response
	res.JSON(http.StatusOK, result)
	[[- end]]
}

// Show handles GET [[.URLPath]]/{id}
func (c *Controller) Show(w http.ResponseWriter, r *http.Request) {
	res := web.NewResponse(w, r)

	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		res.Error(http.StatusBadRequest, "Invalid ID")
		return
	}

	[[.VariableName]], err := c.service.GetByID(r.Context(), uint(id))
	if err != nil {
		res.Error(http.StatusNotFound, err.Error())
		return
	}

	[[- if .WithCrudViews]]
	props := views.[[.ModelName]]ShowProps{
		Item:      [[.VariableName]],
		CSRFToken: middleware.GetCSRFToken(r.Context()),
	}

	// For HTMX partial requests, render just the content
	if res.IsHTMX() {
		c.render(w, r, views.[[.ModelName]]Show(props))
		return
	}

	// For full page requests, wrap in layout
	[[- if eq .Layout "none"]]
	c.render(w, r, views.[[.ModelName]]Show(props))
	[[- else if eq .Layout "base"]]
	c.render(w, r, layouts.BasePage("[[.ModelName]]", views.[[.ModelName]]Show(props)))
	[[- else]]
	c.render(w, r, layouts.DashboardPage("[[.ModelName]]", views.[[.ModelName]]Show(props)))
	[[- end]]
	[[- else]]
	res.JSON(http.StatusOK, [[.PackageName]]svc.To[[.ModelName]]Response([[.VariableName]]))
	[[- end]]
}

// New handles GET [[.URLPath]]/new
func (c *Controller) New(w http.ResponseWriter, r *http.Request) {
	res := web.NewResponse(w, r)
	[[- if .WithCrudViews]]
	[[- if hasBelongsTo .Relationships]]

	// Fetch related records for select dropdowns
	[[- range .Relationships]]
	[[- if .IsBelongsTo]]
	[[.Model | toVariableName]]Result, err := c.[[.Model | toVariableName]]Service.List(r.Context(), [[.Model | toPackageName]]svc.List[[.Model]]Filter{PageSize: 1000})
	if err != nil {
		res.Error(http.StatusInternalServerError, "Failed to load [[.Model | pluralize | toLower]]")
		return
	}
	[[- end]]
	[[- end]]

	props := views.[[.ModelName]]FormProps{
		Item:      nil,
		Errors:    nil,
		IsEdit:    false,
		CSRFToken: middleware.GetCSRFToken(r.Context()),
		[[- range .Relationships]]
		[[- if .IsBelongsTo]]
		[[.Model]]Options: [[.Model | toVariableName]]Result.Items,
		[[- end]]
		[[- end]]
	}

	// For HTMX requests, render just the modal form
	if res.IsHTMX() {
		c.render(w, r, views.[[.ModelName]]Form(props))
		return
	}

	// For direct navigation, wrap in layout
	[[- if eq .Layout "none"]]
	c.render(w, r, views.[[.ModelName]]Form(props))
	[[- else if eq .Layout "base"]]
	c.render(w, r, layouts.BasePage("New [[.ModelName]]", views.[[.ModelName]]Form(props)))
	[[- else]]
	c.render(w, r, layouts.DashboardPage("New [[.ModelName]]", views.[[.ModelName]]Form(props)))
	[[- end]]
	[[- else]]
	props := views.[[.ModelName]]FormProps{
		Item:      nil,
		Errors:    nil,
		IsEdit:    false,
		CSRFToken: middleware.GetCSRFToken(r.Context()),
	}

	// For HTMX requests, render just the modal form
	if res.IsHTMX() {
		c.render(w, r, views.[[.ModelName]]Form(props))
		return
	}

	// For direct navigation, wrap in layout
	[[- if eq .Layout "none"]]
	c.render(w, r, views.[[.ModelName]]Form(props))
	[[- else if eq .Layout "base"]]
	c.render(w, r, layouts.BasePage("New [[.ModelName]]", views.[[.ModelName]]Form(props)))
	[[- else]]
	c.render(w, r, layouts.DashboardPage("New [[.ModelName]]", views.[[.ModelName]]Form(props)))
	[[- end]]
	[[- end]]
	[[- else]]
	res.JSON(http.StatusOK, map[string]string{"action": "new"})
	[[- end]]
}

// Create handles POST [[.URLPath]]
func (c *Controller) Create(w http.ResponseWriter, r *http.Request) {
	res := web.NewResponse(w, r)

	if err := r.ParseForm(); err != nil {
		res.Error(http.StatusBadRequest, "Invalid form data")
		return
	}

	input := [[.PackageName]]svc.Create[[.ModelName]]Input{
	[[- range .Fields]]
	[[- if eq .Type "string"]]
		[[.Name]]: r.FormValue("[[.JSONName]]"),
	[[- else if eq .Type "int"]]
		[[.Name]]: func() int { v, _ := strconv.Atoi(r.FormValue("[[.JSONName]]")); return v }(),
	[[- else if eq .Type "int64"]]
		[[.Name]]: func() int64 { v, _ := strconv.ParseInt(r.FormValue("[[.JSONName]]"), 10, 64); return v }(),
	[[- else if eq .Type "uint"]]
		[[.Name]]: func() uint { v, _ := strconv.ParseUint(r.FormValue("[[.JSONName]]"), 10, 32); return uint(v) }(),
	[[- else if eq .Type "float64"]]
		[[.Name]]: func() float64 { v, _ := strconv.ParseFloat(r.FormValue("[[.JSONName]]"), 64); return v }(),
	[[- else if eq .Type "bool"]]
		[[.Name]]: r.FormValue("[[.JSONName]]") == "true" || r.FormValue("[[.JSONName]]") == "on",
	[[- else if eq .Type "time.Time"]]
		[[.Name]]: func() time.Time { v, _ := time.Parse("2006-01-02T15:04", r.FormValue("[[.JSONName]]")); return v }(),
	[[- else if eq .Type "*time.Time"]]
		[[.Name]]: func() *time.Time { if r.FormValue("[[.JSONName]]") == "" { return nil }; v, _ := time.Parse("2006-01-02", r.FormValue("[[.JSONName]]")); return &v }(),
	[[- else]]
		[[.Name]]: r.FormValue("[[.JSONName]]"),
	[[- end]]
	[[- end]]
	[[- range .Relationships]]
	[[- if .IsBelongsTo]]
		[[.ForeignKey]]: func() uint { v, _ := strconv.ParseUint(r.FormValue("[[.ForeignKey | toJSONTag]]"), 10, 32); return uint(v) }(),
	[[- end]]
	[[- end]]
	}

	[[.VariableName]], err := c.service.Create(r.Context(), input)
	if err != nil {
		[[- if .WithCrudViews]]
		// Re-render form with error
		csrfToken := middleware.GetCSRFToken(r.Context())
		c.render(w, r, views.[[.ModelName]]Form(views.[[.ModelName]]FormProps{
			Item:      nil,
			Errors:    map[string]string{"_error": err.Error()},
			IsEdit:    false,
			CSRFToken: csrfToken,
		}))
		return
		[[- else]]
		res.Error(http.StatusInternalServerError, err.Error())
		return
		[[- end]]
	}

	// Handle response based on request type
	redirectURL := "[[.URLPath]]/" + strconv.FormatUint(uint64([[.VariableName]].ID), 10)

	if res.IsHTMX() {
		res.Success("[[.ModelName]] created successfully")
		res.Redirect(redirectURL)
		return
	}

	// For API requests (Accept: application/json), return JSON
	// For browser form submissions, redirect to the new resource
	if r.Header.Get("Accept") == "application/json" {
		w.WriteHeader(http.StatusCreated)
		res.JSON(http.StatusCreated, [[.PackageName]]svc.To[[.ModelName]]Response([[.VariableName]]))
		return
	}

	// Browser form submission - redirect
	http.Redirect(w, r, redirectURL, http.StatusSeeOther)
}

// Edit handles GET [[.URLPath]]/{id}/edit
func (c *Controller) Edit(w http.ResponseWriter, r *http.Request) {
	res := web.NewResponse(w, r)

	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		res.Error(http.StatusBadRequest, "Invalid ID")
		return
	}

	[[.VariableName]], err := c.service.GetByID(r.Context(), uint(id))
	if err != nil {
		res.Error(http.StatusNotFound, err.Error())
		return
	}

	[[- if .WithCrudViews]]
	[[- if hasBelongsTo .Relationships]]
	// Fetch related records for select dropdowns
	[[- range .Relationships]]
	[[- if .IsBelongsTo]]
	[[.Model | toVariableName]]Result, err := c.[[.Model | toVariableName]]Service.List(r.Context(), [[.Model | toPackageName]]svc.List[[.Model]]Filter{PageSize: 1000})
	if err != nil {
		res.Error(http.StatusInternalServerError, "Failed to load [[.Model | pluralize | toLower]]")
		return
	}
	[[- end]]
	[[- end]]

	props := views.[[.ModelName]]FormProps{
		Item:      [[$.VariableName]],
		Errors:    nil,
		IsEdit:    true,
		CSRFToken: middleware.GetCSRFToken(r.Context()),
		[[- range .Relationships]]
		[[- if .IsBelongsTo]]
		[[.Model]]Options: [[.Model | toVariableName]]Result.Items,
		[[- end]]
		[[- end]]
	}

	// For HTMX requests, render just the modal form
	if res.IsHTMX() {
		c.render(w, r, views.[[.ModelName]]Form(props))
		return
	}

	// For direct navigation, wrap in layout
	[[- if eq .Layout "none"]]
	c.render(w, r, views.[[.ModelName]]Form(props))
	[[- else if eq .Layout "base"]]
	c.render(w, r, layouts.BasePage("Edit [[.ModelName]]", views.[[.ModelName]]Form(props)))
	[[- else]]
	c.render(w, r, layouts.DashboardPage("Edit [[.ModelName]]", views.[[.ModelName]]Form(props)))
	[[- end]]
	[[- else]]
	props := views.[[.ModelName]]FormProps{
		Item:      [[$.VariableName]],
		Errors:    nil,
		IsEdit:    true,
		CSRFToken: middleware.GetCSRFToken(r.Context()),
	}

	// For HTMX requests, render just the modal form
	if res.IsHTMX() {
		c.render(w, r, views.[[.ModelName]]Form(props))
		return
	}

	// For direct navigation, wrap in layout
	[[- if eq .Layout "none"]]
	c.render(w, r, views.[[.ModelName]]Form(props))
	[[- else if eq .Layout "base"]]
	c.render(w, r, layouts.BasePage("Edit [[.ModelName]]", views.[[.ModelName]]Form(props)))
	[[- else]]
	c.render(w, r, layouts.DashboardPage("Edit [[.ModelName]]", views.[[.ModelName]]Form(props)))
	[[- end]]
	[[- end]]
	[[- else]]
	res.JSON(http.StatusOK, [[.PackageName]]svc.To[[.ModelName]]Response([[.VariableName]]))
	[[- end]]
}

// Update handles PUT [[.URLPath]]/{id}
func (c *Controller) Update(w http.ResponseWriter, r *http.Request) {
	res := web.NewResponse(w, r)

	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		res.Error(http.StatusBadRequest, "Invalid ID")
		return
	}

	if err := r.ParseForm(); err != nil {
		res.Error(http.StatusBadRequest, "Invalid form data")
		return
	}

	// Build input with pointer fields for partial updates
	input := [[.PackageName]]svc.Update[[.ModelName]]Input{}
	[[- range .Fields]]
	[[- if eq .Type "string"]]
	if v := r.FormValue("[[.JSONName]]"); v != "" {
		input.[[.Name]] = &v
	}
	[[- else if eq .Type "int"]]
	if v := r.FormValue("[[.JSONName]]"); v != "" {
		if i, err := strconv.Atoi(v); err == nil {
			input.[[.Name]] = &i
		}
	}
	[[- else if eq .Type "int64"]]
	if v := r.FormValue("[[.JSONName]]"); v != "" {
		if i, err := strconv.ParseInt(v, 10, 64); err == nil {
			input.[[.Name]] = &i
		}
	}
	[[- else if eq .Type "uint"]]
	if v := r.FormValue("[[.JSONName]]"); v != "" {
		if i, err := strconv.ParseUint(v, 10, 32); err == nil {
			u := uint(i)
			input.[[.Name]] = &u
		}
	}
	[[- else if eq .Type "float64"]]
	if v := r.FormValue("[[.JSONName]]"); v != "" {
		if f, err := strconv.ParseFloat(v, 64); err == nil {
			input.[[.Name]] = &f
		}
	}
	[[- else if eq .Type "bool"]]
	// For checkboxes, explicit handling: form sends "true"/"on" when checked
	{
		boolVal := r.FormValue("[[.JSONName]]") == "true" || r.FormValue("[[.JSONName]]") == "on"
		input.[[.Name]] = &boolVal
	}
	[[- else if eq .Type "time.Time"]]
	if v := r.FormValue("[[.JSONName]]"); v != "" {
		if t, err := time.Parse("2006-01-02T15:04", v); err == nil {
			input.[[.Name]] = &t
		}
	}
	[[- else if eq .Type "*time.Time"]]
	if v := r.FormValue("[[.JSONName]]"); v != "" {
		if t, err := time.Parse("2006-01-02", v); err == nil {
			input.[[.Name]] = &t
		}
	}
	[[- else]]
	if v := r.FormValue("[[.JSONName]]"); v != "" {
		input.[[.Name]] = &v
	}
	[[- end]]
	[[- end]]
	[[- range .Relationships]]
	[[- if .IsBelongsTo]]
	if v := r.FormValue("[[.ForeignKey | toJSONTag]]"); v != "" {
		if i, err := strconv.ParseUint(v, 10, 32); err == nil {
			u := uint(i)
			input.[[.ForeignKey]] = &u
		}
	}
	[[- end]]
	[[- end]]

	[[.VariableName]], err := c.service.Update(r.Context(), uint(id), input)
	if err != nil {
		if err == [[.PackageName]]svc.Err[[.ModelName]]NotFound {
			res.Error(http.StatusNotFound, err.Error())
			return
		}
		[[- if .WithCrudViews]]
		// Re-fetch item for re-rendering form with error
		existing, _ := c.service.GetByID(r.Context(), uint(id))
		csrfToken := middleware.GetCSRFToken(r.Context())
		c.render(w, r, views.[[.ModelName]]Form(views.[[.ModelName]]FormProps{
			Item:      existing,
			Errors:    map[string]string{"_error": err.Error()},
			IsEdit:    true,
			CSRFToken: csrfToken,
		}))
		return
		[[- else]]
		res.Error(http.StatusInternalServerError, err.Error())
		return
		[[- end]]
	}

	// Handle response based on request type
	redirectURL := "[[.URLPath]]/" + strconv.FormatUint(uint64([[.VariableName]].ID), 10)

	if res.IsHTMX() {
		res.Success("[[.ModelName]] updated successfully")
		res.Redirect(redirectURL)
		return
	}

	// For API requests (Accept: application/json), return JSON
	// For browser form submissions, redirect to the updated resource
	if r.Header.Get("Accept") == "application/json" {
		res.JSON(http.StatusOK, [[.PackageName]]svc.To[[.ModelName]]Response([[.VariableName]]))
		return
	}

	// Browser form submission - redirect
	http.Redirect(w, r, redirectURL, http.StatusSeeOther)
}

// Delete handles DELETE [[.URLPath]]/{id}
func (c *Controller) Delete(w http.ResponseWriter, r *http.Request) {
	res := web.NewResponse(w, r)

	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		res.Error(http.StatusBadRequest, "Invalid ID")
		return
	}

	if err := c.service.Delete(r.Context(), uint(id)); err != nil {
		if err == [[.PackageName]]svc.Err[[.ModelName]]NotFound {
			res.Error(http.StatusNotFound, err.Error())
			return
		}
		res.Error(http.StatusInternalServerError, err.Error())
		return
	}

	if res.IsHTMX() {
		res.Success("[[.ModelName]] deleted successfully")
		w.WriteHeader(http.StatusOK)
		return
	}

	// For API requests, return 204 No Content
	// For browser requests, redirect to the list page
	if r.Header.Get("Accept") == "application/json" {
		w.WriteHeader(http.StatusNoContent)
		return
	}

	// Browser request - redirect to list
	http.Redirect(w, r, "[[.URLPath]]", http.StatusSeeOther)
}

// MCP:HANDLERS:START
// MCP:HANDLERS:END
