package [[.PackageName]]

import (
	"context"
	"errors"

	"[[.ModulePath]]/internal/models"
	[[.PackageName]]repo "[[.ModulePath]]/internal/repository/[[.PackageName]]"
)

var (
	// Err[[.ModelName]]NotFound is returned when a [[.ModelName]] is not found.
	Err[[.ModelName]]NotFound = errors.New("[[.DomainName]] not found")
)

// Service defines the interface for [[.ModelName]] business operations.
type Service interface {
	Create(ctx context.Context, input Create[[.ModelName]]Input) (*models.[[.ModelName]], error)
	GetByID(ctx context.Context, id uint) (*models.[[.ModelName]], error)
[[- if .HasRelationships]]
	GetByIDWithRelations(ctx context.Context, id uint, preloads ...string) (*models.[[.ModelName]], error)
[[- end]]
	List(ctx context.Context, filter List[[.ModelName]]Filter) (*List[[.ModelName]]Result, error)
	Update(ctx context.Context, id uint, input Update[[.ModelName]]Input) (*models.[[.ModelName]], error)
	Delete(ctx context.Context, id uint) error
	// MCP:SERVICE_INTERFACE:START
	// MCP:SERVICE_INTERFACE:END
}

// service implements Service.
type service struct {
	repo [[.PackageName]]repo.Repository
}

// NewService creates a new [[.ModelName]] service.
func NewService(repo [[.PackageName]]repo.Repository) Service {
	return &service{repo: repo}
}

// Create creates a new [[.ModelName]].
func (s *service) Create(ctx context.Context, input Create[[.ModelName]]Input) (*models.[[.ModelName]], error) {
	[[.VariableName]] := &models.[[.ModelName]]{
[[- range .Fields]]
		[[.Name]]: input.[[.Name]],
[[- end]]
[[- range .Relationships]]
[[- if .IsBelongsTo]]
		[[.ForeignKey]]: input.[[.ForeignKey]],
[[- end]]
[[- end]]
	}

	if err := s.repo.Create(ctx, [[.VariableName]]); err != nil {
		return nil, err
	}

	return [[.VariableName]], nil
}

// GetByID gets a [[.ModelName]] by ID.
func (s *service) GetByID(ctx context.Context, id uint) (*models.[[.ModelName]], error) {
	[[.VariableName]], err := s.repo.FindByID(ctx, id)
	if err != nil {
		return nil, Err[[.ModelName]]NotFound
	}
	return [[.VariableName]], nil
}
[[- if .HasRelationships]]

// GetByIDWithRelations gets a [[.ModelName]] by ID with specified relationships preloaded.
// If no preloads are specified, it loads the default preloaded relationships.
func (s *service) GetByIDWithRelations(ctx context.Context, id uint, preloads ...string) (*models.[[.ModelName]], error) {
	[[.VariableName]], err := s.repo.FindByIDWithRelations(ctx, id, preloads...)
	if err != nil {
		return nil, Err[[.ModelName]]NotFound
	}
	return [[.VariableName]], nil
}
[[- end]]

// List lists [[pluralize .ModelName]] with filtering and pagination.
func (s *service) List(ctx context.Context, filter List[[.ModelName]]Filter) (*List[[.ModelName]]Result, error) {
	var opts [][[.PackageName]]repo.QueryOption

	// Apply pagination
	if filter.Page > 0 || filter.PageSize > 0 {
		page := filter.Page
		if page < 1 {
			page = 1
		}
		pageSize := filter.PageSize
		if pageSize < 1 {
			pageSize = 10
		}
		opts = append(opts, [[.PackageName]]repo.WithPagination(page, pageSize))
	}

	// Apply search if provided
	if filter.Search != "" {
		opts = append(opts, [[.PackageName]]repo.WithSearch("name", filter.Search))
	}

	// Apply ordering
	if filter.SortBy != "" {
		opts = append(opts, [[.PackageName]]repo.WithOrder(filter.SortBy, filter.SortDesc))
	} else {
		opts = append(opts, [[.PackageName]]repo.WithOrder("created_at", true))
	}
[[- if .HasRelationships]]

	// Apply preloads if specified
	if len(filter.Preloads) > 0 {
		opts = append(opts, [[.PackageName]]repo.WithPreloads(filter.Preloads...))
	}
[[- end]]

	[[pluralize .VariableName]], total, err := s.repo.FindAll(ctx, opts...)
	if err != nil {
		return nil, err
	}

	// Calculate pagination values
	page := filter.Page
	if page < 1 {
		page = 1
	}
	pageSize := filter.PageSize
	if pageSize < 1 {
		pageSize = 10
	}
	totalPages := int(total) / pageSize
	if int(total)%pageSize > 0 {
		totalPages++
	}

	return &List[[.ModelName]]Result{
		Items:      [[pluralize .VariableName]],
		Total:      total,
		Page:       page,
		PageSize:   pageSize,
		TotalPages: totalPages,
		TotalItems: int(total),
	}, nil
}

// Update updates a [[.ModelName]].
func (s *service) Update(ctx context.Context, id uint, input Update[[.ModelName]]Input) (*models.[[.ModelName]], error) {
	[[.VariableName]], err := s.repo.FindByID(ctx, id)
	if err != nil {
		return nil, Err[[.ModelName]]NotFound
	}

[[- range .Fields]]
	if input.[[.Name]] != nil {
		[[$.VariableName]].[[.Name]] = *input.[[.Name]]
	}
[[- end]]
[[- range .Relationships]]
[[- if .IsBelongsTo]]
	if input.[[.ForeignKey]] != nil {
		[[$.VariableName]].[[.ForeignKey]] = *input.[[.ForeignKey]]
	}
[[- end]]
[[- end]]

	if err := s.repo.Update(ctx, [[.VariableName]]); err != nil {
		return nil, err
	}

	return [[.VariableName]], nil
}

// Delete deletes a [[.ModelName]].
func (s *service) Delete(ctx context.Context, id uint) error {
	_, err := s.repo.FindByID(ctx, id)
	if err != nil {
		return Err[[.ModelName]]NotFound
	}
	return s.repo.Delete(ctx, id)
}

// MCP:SERVICE_METHODS:START
// MCP:SERVICE_METHODS:END
