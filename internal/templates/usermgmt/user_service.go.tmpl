package user

import (
	"context"
	"errors"

	"[[.ModulePath]]/internal/models"
	userrepo "[[.ModulePath]]/internal/repository/user"
	"golang.org/x/crypto/bcrypt"
)

var (
	// ErrUserNotFound is returned when a user is not found.
	ErrUserNotFound = errors.New("user not found")
	// ErrEmailExists is returned when trying to create a user with an existing email.
	ErrEmailExists = errors.New("email already exists")
)

// Service provides user management operations.
type Service struct {
	repo *userrepo.Repository
}

// NewService creates a new user management Service.
func NewService(repo *userrepo.Repository) *Service {
	return &Service{repo: repo}
}

// ListUsers returns a paginated list of users.
func (s *Service) ListUsers(ctx context.Context, page, pageSize int, search string) ([]models.User, int64, error) {
	opts := []userrepo.QueryOption{
		userrepo.WithPreloadRole(),
		userrepo.WithPagination(page, pageSize),
		userrepo.WithOrder("created_at", true),
	}
	if search != "" {
		opts = append(opts, userrepo.WithSearch(search))
	}
	return s.repo.FindAll(ctx, opts...)
}

// GetUser returns a user by ID.
func (s *Service) GetUser(ctx context.Context, id uint) (*models.User, error) {
	user, err := s.repo.FindByID(ctx, id)
	if err != nil {
		return nil, ErrUserNotFound
	}
	return user, nil
}

// CreateUser creates a new user.
func (s *Service) CreateUser(ctx context.Context, name, email, password string, roleID uint, active bool) (*models.User, error) {
	// Check if email exists
	exists, err := s.repo.ExistsByEmail(ctx, email)
	if err != nil {
		return nil, err
	}
	if exists {
		return nil, ErrEmailExists
	}

	// Hash password
	hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return nil, err
	}

	user := &models.User{
		Name:         name,
		Email:        email,
		PasswordHash: string(hash),
		RoleID:       roleID,
		Active:       active,
	}

	if err := s.repo.Create(ctx, user); err != nil {
		return nil, err
	}

	return user, nil
}

// UpdateUser updates a user's details.
func (s *Service) UpdateUser(ctx context.Context, id uint, name, email string, roleID uint, active bool) (*models.User, error) {
	user, err := s.repo.FindByID(ctx, id)
	if err != nil {
		return nil, ErrUserNotFound
	}

	// Check if email is taken by another user
	if user.Email != email {
		exists, err := s.repo.ExistsByEmail(ctx, email)
		if err != nil {
			return nil, err
		}
		if exists {
			return nil, ErrEmailExists
		}
	}

	user.Name = name
	user.Email = email
	user.RoleID = roleID
	user.Active = active

	if err := s.repo.Update(ctx, user); err != nil {
		return nil, err
	}

	return user, nil
}

// UpdatePassword updates a user's password.
func (s *Service) UpdatePassword(ctx context.Context, id uint, password string) error {
	user, err := s.repo.FindByID(ctx, id)
	if err != nil {
		return ErrUserNotFound
	}

	hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return err
	}

	user.PasswordHash = string(hash)
	return s.repo.Update(ctx, user)
}

// DeleteUser deletes a user.
func (s *Service) DeleteUser(ctx context.Context, id uint) error {
	return s.repo.Delete(ctx, id)
}

// ToggleActive toggles a user's active status.
func (s *Service) ToggleActive(ctx context.Context, id uint) error {
	user, err := s.repo.FindByID(ctx, id)
	if err != nil {
		return ErrUserNotFound
	}
	return s.repo.SetActive(ctx, id, !user.Active)
}

// GetRoles returns all available roles.
func (s *Service) GetRoles(ctx context.Context) ([]models.Role, error) {
	return s.repo.FindAllRoles(ctx)
}
