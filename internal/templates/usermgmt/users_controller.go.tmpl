package users

import (
	"net/http"
	"strconv"

	"[[.ModulePath]]/internal/services/auth"
	usersvc "[[.ModulePath]]/internal/services/user"
	"[[.ModulePath]]/internal/web"
	"[[.ModulePath]]/internal/web/layouts"
	authmiddleware "[[.ModulePath]]/internal/web/middleware"
	"[[.ModulePath]]/internal/web/users/views"
	"github.com/go-chi/chi/v5"
)

// Controller handles user management HTTP requests.
type Controller struct {
	userService *usersvc.Service
	authService *auth.Service
}

// NewController creates a new users Controller.
func NewController(userService *usersvc.Service, authService *auth.Service) *Controller {
	return &Controller{
		userService: userService,
		authService: authService,
	}
}

// RegisterRoutes registers user management routes on the given router.
// Routes should be protected by RequireAuth + RequireAdmin middleware.
func (c *Controller) RegisterRoutes(r chi.Router) {
	r.Get("/", c.List)
	r.Get("/new", c.New)
	r.Post("/", c.Create)
	r.Get("/{id}", c.Show)
	r.Get("/{id}/edit", c.Edit)
	r.Put("/{id}", c.Update)
	r.Post("/{id}", c.Update) // For HTML form compatibility
	r.Delete("/{id}", c.Delete)
	r.Post("/{id}/toggle-active", c.ToggleActive)
	r.Get("/{id}/password", c.EditPassword)
	r.Post("/{id}/password", c.UpdatePassword)
}

// List renders the users list page.
func (c *Controller) List(w http.ResponseWriter, r *http.Request) {
	res := web.NewResponse(w, r)

	page, _ := strconv.Atoi(r.URL.Query().Get("page"))
	if page < 1 {
		page = 1
	}
	pageSize := 20
	search := r.URL.Query().Get("search")

	users, total, err := c.userService.ListUsers(r.Context(), page, pageSize, search)
	if err != nil {
		res.Error(http.StatusInternalServerError, "Failed to load users")
		return
	}

	totalPages := int((total + int64(pageSize) - 1) / int64(pageSize))

	props := views.ListProps{
		Users:       users,
		Page:        page,
		PageSize:    pageSize,
		TotalPages:  totalPages,
		TotalCount:  int(total),
		Search:      search,
		CSRFToken:   authmiddleware.GetCSRFToken(r.Context()),
	}

	if res.IsHTMX() {
		res.Render(views.UsersTable(props))
		return
	}

	res.Render(layouts.DashboardPage("Users", views.ListPage(props)))
}

// New renders the new user form.
func (c *Controller) New(w http.ResponseWriter, r *http.Request) {
	res := web.NewResponse(w, r)

	roles, err := c.userService.GetRoles(r.Context())
	if err != nil {
		res.Error(http.StatusInternalServerError, "Failed to load roles")
		return
	}

	props := views.FormProps{
		Roles:     roles,
		IsEdit:    false,
		CSRFToken: authmiddleware.GetCSRFToken(r.Context()),
	}

	if res.IsHTMX() {
		res.Render(views.UserForm(props))
		return
	}

	res.Render(layouts.DashboardPage("New User", views.FormPage(props)))
}

// Create handles the new user form submission.
func (c *Controller) Create(w http.ResponseWriter, r *http.Request) {
	res := web.NewResponse(w, r)

	if err := r.ParseForm(); err != nil {
		res.Error(http.StatusBadRequest, "Invalid form data")
		return
	}

	name := r.FormValue("name")
	email := r.FormValue("email")
	password := r.FormValue("password")
	roleID, _ := strconv.ParseUint(r.FormValue("role_id"), 10, 32)
	active := r.FormValue("active") == "on" || r.FormValue("active") == "true"

	// Validate
	errors := make(map[string]string)
	if name == "" {
		errors["name"] = "Name is required"
	}
	if email == "" {
		errors["email"] = "Email is required"
	}
	if password == "" {
		errors["password"] = "Password is required"
	} else if len(password) < 8 {
		errors["password"] = "Password must be at least 8 characters"
	}
	if roleID == 0 {
		errors["role_id"] = "Role is required"
	}

	if len(errors) > 0 {
		roles, _ := c.userService.GetRoles(r.Context())
		props := views.FormProps{
			Name:      name,
			Email:     email,
			RoleID:    uint(roleID),
			Active:    active,
			Roles:     roles,
			Errors:    errors,
			IsEdit:    false,
			CSRFToken: authmiddleware.GetCSRFToken(r.Context()),
		}
		res.Render(views.UserForm(props))
		return
	}

	_, err := c.userService.CreateUser(r.Context(), name, email, password, uint(roleID), active)
	if err != nil {
		if err == usersvc.ErrEmailExists {
			roles, _ := c.userService.GetRoles(r.Context())
			props := views.FormProps{
				Name:      name,
				Email:     email,
				RoleID:    uint(roleID),
				Active:    active,
				Roles:     roles,
				Errors:    map[string]string{"email": "Email already exists"},
				IsEdit:    false,
				CSRFToken: authmiddleware.GetCSRFToken(r.Context()),
			}
			res.Render(views.UserForm(props))
			return
		}
		res.Error(http.StatusInternalServerError, "Failed to create user")
		return
	}

	c.authService.AddFlashSuccess(w, r, "User created successfully")

	if res.IsHTMX() {
		res.Redirect("/admin/users")
		return
	}

	http.Redirect(w, r, "/admin/users", http.StatusSeeOther)
}

// Show renders the user details page.
func (c *Controller) Show(w http.ResponseWriter, r *http.Request) {
	res := web.NewResponse(w, r)

	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		res.Error(http.StatusBadRequest, "Invalid user ID")
		return
	}

	user, err := c.userService.GetUser(r.Context(), uint(id))
	if err != nil {
		res.Error(http.StatusNotFound, "User not found")
		return
	}

	// Get current user ID for self-action prevention
	var currentUserID uint
	if currentUser := authmiddleware.GetUserFromContext(r.Context()); currentUser != nil {
		currentUserID = currentUser.ID
	}

	props := views.ShowProps{
		User:          user,
		CurrentUserID: currentUserID,
		CSRFToken:     authmiddleware.GetCSRFToken(r.Context()),
	}

	if res.IsHTMX() {
		res.Render(views.UserDetail(props))
		return
	}

	res.Render(layouts.DashboardPage("User Details", views.ShowPage(props)))
}

// Edit renders the edit user form.
func (c *Controller) Edit(w http.ResponseWriter, r *http.Request) {
	res := web.NewResponse(w, r)

	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		res.Error(http.StatusBadRequest, "Invalid user ID")
		return
	}

	user, err := c.userService.GetUser(r.Context(), uint(id))
	if err != nil {
		res.Error(http.StatusNotFound, "User not found")
		return
	}

	roles, err := c.userService.GetRoles(r.Context())
	if err != nil {
		res.Error(http.StatusInternalServerError, "Failed to load roles")
		return
	}

	props := views.FormProps{
		UserID:    user.ID,
		Name:      user.Name,
		Email:     user.Email,
		RoleID:    user.RoleID,
		Active:    user.Active,
		Roles:     roles,
		IsEdit:    true,
		CSRFToken: authmiddleware.GetCSRFToken(r.Context()),
	}

	if res.IsHTMX() {
		res.Render(views.UserForm(props))
		return
	}

	res.Render(layouts.DashboardPage("Edit User", views.FormPage(props)))
}

// Update handles the edit user form submission.
func (c *Controller) Update(w http.ResponseWriter, r *http.Request) {
	res := web.NewResponse(w, r)

	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		res.Error(http.StatusBadRequest, "Invalid user ID")
		return
	}

	if err := r.ParseForm(); err != nil {
		res.Error(http.StatusBadRequest, "Invalid form data")
		return
	}

	name := r.FormValue("name")
	email := r.FormValue("email")
	roleID, _ := strconv.ParseUint(r.FormValue("role_id"), 10, 32)
	active := r.FormValue("active") == "on" || r.FormValue("active") == "true"

	// Validate
	errors := make(map[string]string)
	if name == "" {
		errors["name"] = "Name is required"
	}
	if email == "" {
		errors["email"] = "Email is required"
	}
	if roleID == 0 {
		errors["role_id"] = "Role is required"
	}

	if len(errors) > 0 {
		roles, _ := c.userService.GetRoles(r.Context())
		props := views.FormProps{
			UserID:    uint(id),
			Name:      name,
			Email:     email,
			RoleID:    uint(roleID),
			Active:    active,
			Roles:     roles,
			Errors:    errors,
			IsEdit:    true,
			CSRFToken: authmiddleware.GetCSRFToken(r.Context()),
		}
		res.Render(views.UserForm(props))
		return
	}

	_, err = c.userService.UpdateUser(r.Context(), uint(id), name, email, uint(roleID), active)
	if err != nil {
		if err == usersvc.ErrEmailExists {
			roles, _ := c.userService.GetRoles(r.Context())
			props := views.FormProps{
				UserID:    uint(id),
				Name:      name,
				Email:     email,
				RoleID:    uint(roleID),
				Active:    active,
				Roles:     roles,
				Errors:    map[string]string{"email": "Email already exists"},
				IsEdit:    true,
				CSRFToken: authmiddleware.GetCSRFToken(r.Context()),
			}
			res.Render(views.UserForm(props))
			return
		}
		res.Error(http.StatusInternalServerError, "Failed to update user")
		return
	}

	c.authService.AddFlashSuccess(w, r, "User updated successfully")

	if res.IsHTMX() {
		res.Redirect("/admin/users")
		return
	}

	http.Redirect(w, r, "/admin/users", http.StatusSeeOther)
}

// Delete handles user deletion.
func (c *Controller) Delete(w http.ResponseWriter, r *http.Request) {
	res := web.NewResponse(w, r)

	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		res.Error(http.StatusBadRequest, "Invalid user ID")
		return
	}

	// Prevent self-deletion
	currentUser := authmiddleware.GetUserFromContext(r.Context())
	if currentUser != nil && currentUser.ID == uint(id) {
		res.Error(http.StatusForbidden, "Cannot delete your own account")
		return
	}

	if err := c.userService.DeleteUser(r.Context(), uint(id)); err != nil {
		res.Error(http.StatusInternalServerError, "Failed to delete user")
		return
	}

	c.authService.AddFlashSuccess(w, r, "User deleted successfully")

	if res.IsHTMX() {
		res.Redirect("/admin/users")
		return
	}

	http.Redirect(w, r, "/admin/users", http.StatusSeeOther)
}

// ToggleActive toggles a user's active status.
func (c *Controller) ToggleActive(w http.ResponseWriter, r *http.Request) {
	res := web.NewResponse(w, r)

	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		res.Error(http.StatusBadRequest, "Invalid user ID")
		return
	}

	// Prevent self-deactivation
	currentUser := authmiddleware.GetUserFromContext(r.Context())
	if currentUser != nil && currentUser.ID == uint(id) {
		res.Error(http.StatusForbidden, "Cannot change your own active status")
		return
	}

	if err := c.userService.ToggleActive(r.Context(), uint(id)); err != nil {
		res.Error(http.StatusInternalServerError, "Failed to update user status")
		return
	}

	c.authService.AddFlashSuccess(w, r, "User status updated")

	if res.IsHTMX() {
		w.Header().Set("HX-Refresh", "true")
		return
	}

	http.Redirect(w, r, "/admin/users", http.StatusSeeOther)
}

// EditPassword renders the password change form.
func (c *Controller) EditPassword(w http.ResponseWriter, r *http.Request) {
	res := web.NewResponse(w, r)

	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		res.Error(http.StatusBadRequest, "Invalid user ID")
		return
	}

	user, err := c.userService.GetUser(r.Context(), uint(id))
	if err != nil {
		res.Error(http.StatusNotFound, "User not found")
		return
	}

	props := views.PasswordProps{
		UserID:    user.ID,
		UserName:  user.Name,
		CSRFToken: authmiddleware.GetCSRFToken(r.Context()),
	}

	if res.IsHTMX() {
		res.Render(views.PasswordForm(props))
		return
	}

	res.Render(layouts.DashboardPage("Change Password", views.PasswordPage(props)))
}

// UpdatePassword handles the password change form submission.
func (c *Controller) UpdatePassword(w http.ResponseWriter, r *http.Request) {
	res := web.NewResponse(w, r)

	id, err := strconv.ParseUint(chi.URLParam(r, "id"), 10, 32)
	if err != nil {
		res.Error(http.StatusBadRequest, "Invalid user ID")
		return
	}

	if err := r.ParseForm(); err != nil {
		res.Error(http.StatusBadRequest, "Invalid form data")
		return
	}

	password := r.FormValue("password")
	confirmPassword := r.FormValue("confirm_password")

	// Validate
	errors := make(map[string]string)
	if password == "" {
		errors["password"] = "Password is required"
	} else if len(password) < 8 {
		errors["password"] = "Password must be at least 8 characters"
	}
	if password != confirmPassword {
		errors["confirm_password"] = "Passwords do not match"
	}

	if len(errors) > 0 {
		user, _ := c.userService.GetUser(r.Context(), uint(id))
		props := views.PasswordProps{
			UserID:    uint(id),
			UserName:  user.Name,
			Errors:    errors,
			CSRFToken: authmiddleware.GetCSRFToken(r.Context()),
		}
		res.Render(views.PasswordForm(props))
		return
	}

	if err := c.userService.UpdatePassword(r.Context(), uint(id), password); err != nil {
		res.Error(http.StatusInternalServerError, "Failed to update password")
		return
	}

	c.authService.AddFlashSuccess(w, r, "Password updated successfully")

	if res.IsHTMX() {
		res.Redirect("/admin/users")
		return
	}

	http.Redirect(w, r, "/admin/users", http.StatusSeeOther)
}
